#!/usr/bin/env node

/**
 * üìä MONITORING DASHBOARD
 * 
 * Dashboard en temps r√©el pour le monitoring du syst√®me multi-agents
 * M√©triques, alertes, et visualisation de l'√©tat du syst√®me
 */

import { EventEmitter } from 'events';
import chalk from 'chalk';
import { promises as fs } from 'fs';
import path from 'path';

export class MonitoringDashboard extends EventEmitter {
  constructor(orchestrator) {
    super();
    
    this.orchestrator = orchestrator;
    this.metrics = {
      system: {
        startTime: Date.now(),
        uptime: 0,
        totalTasks: 0,
        completedTasks: 0,
        failedTasks: 0,
        activeAgents: 0,
        messagesExchanged: 0
      },
      agents: new Map(),
      tasks: new Map(),
      alerts: [],
      performance: {
        avgTaskTime: 0,
        systemLoad: 0,
        memoryUsage: 0,
        context7Hits: 0,
        context7Misses: 0
      }
    };
    
    this.alertRules = new Map();
    this.setupDefaultAlerts();
    this.isRunning = false;
    this.refreshInterval = null;
    this.logFile = path.join(process.cwd(), 'logs', 'monitoring.log');
  }

  /**
   * üöÄ D√âMARRAGE DU DASHBOARD
   */
  async start() {
    if (this.isRunning) {
      return;
    }

    this.isRunning = true;
    console.clear();
    this.log('üöÄ D√©marrage du dashboard de monitoring...');

    // S'abonner aux √©v√©nements de l'orchestrateur
    this.setupEventListeners();

    // D√©marrer le monitoring en temps r√©el
    this.refreshInterval = setInterval(() => {
      this.updateDisplay();
    }, 1000); // Refresh toutes les secondes

    // Premi√®re affichage
    this.updateDisplay();

    // Monitoring des performances syst√®me
    this.startSystemMonitoring();

    this.log('‚úÖ Dashboard de monitoring d√©marr√©');
  }

  /**
   * ‚èπÔ∏è ARR√äT DU DASHBOARD
   */
  async stop() {
    if (!this.isRunning) {
      return;
    }

    this.isRunning = false;
    
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
      this.refreshInterval = null;
    }

    // Sauvegarder les m√©triques finales
    await this.saveMetrics();

    console.log(chalk.yellow('\nüìä Dashboard de monitoring arr√™t√©'));
    this.log('‚èπÔ∏è Dashboard de monitoring arr√™t√©');
  }

  /**
   * üéß CONFIGURATION DES LISTENERS
   */
  setupEventListeners() {
    if (!this.orchestrator) return;

    // √âv√©nements des agents
    this.orchestrator.on('agentRegistered', (data) => {
      this.handleAgentRegistered(data);
    });

    this.orchestrator.on('taskStarted', (data) => {
      this.handleTaskStarted(data);
    });

    this.orchestrator.on('taskCompleted', (data) => {
      this.handleTaskCompleted(data);
    });

    this.orchestrator.on('taskFailed', (data) => {
      this.handleTaskFailed(data);
    });

    this.orchestrator.on('messageExchanged', (data) => {
      this.handleMessageExchanged(data);
    });

    this.orchestrator.on('context7Query', (data) => {
      this.handleContext7Query(data);
    });

    this.orchestrator.on('healthUpdate', (data) => {
      this.handleHealthUpdate(data);
    });

    this.orchestrator.on('performanceAlert', (data) => {
      this.handlePerformanceAlert(data);
    });
  }

  /**
   * üîî GESTION DES √âV√âNEMENTS
   */
  handleAgentRegistered(data) {
    this.metrics.system.activeAgents++;
    this.metrics.agents.set(data.agentId, {
      id: data.agentId,
      name: data.name,
      specialization: data.specialization,
      status: 'idle',
      registeredAt: Date.now(),
      tasksCompleted: 0,
      tasksFailed: 0,
      avgTaskTime: 0,
      health: 'healthy',
      lastActivity: Date.now()
    });

    this.log(`ü§ñ Agent enregistr√©: ${data.agentId}`);
  }

  handleTaskStarted(data) {
    this.metrics.system.totalTasks++;
    
    const task = {
      id: data.task.id,
      agentId: data.agent,
      type: data.task.type,
      description: data.task.description,
      priority: data.task.priority,
      startTime: Date.now(),
      status: 'running'
    };
    
    this.metrics.tasks.set(data.task.id, task);

    // Mettre √† jour l'agent
    const agent = this.metrics.agents.get(data.agent);
    if (agent) {
      agent.status = 'working';
      agent.lastActivity = Date.now();
    }

    this.log(`üöÄ T√¢che d√©marr√©e: ${data.task.id} par ${data.agent}`);
  }

  handleTaskCompleted(data) {
    this.metrics.system.completedTasks++;
    
    const task = this.metrics.tasks.get(data.task.id);
    if (task) {
      task.status = 'completed';
      task.endTime = Date.now();
      task.duration = task.endTime - task.startTime;
      task.result = data.result;
    }

    // Mettre √† jour l'agent
    const agent = this.metrics.agents.get(data.agent);
    if (agent) {
      agent.status = 'idle';
      agent.tasksCompleted++;
      agent.lastActivity = Date.now();
      
      // Calculer la moyenne mobile du temps d'ex√©cution
      if (task && task.duration) {
        const totalTime = agent.avgTaskTime * (agent.tasksCompleted - 1) + task.duration;
        agent.avgTaskTime = Math.round(totalTime / agent.tasksCompleted);
      }
    }

    // Mettre √† jour les m√©triques de performance
    this.updatePerformanceMetrics();

    this.log(`‚úÖ T√¢che compl√©t√©e: ${data.task.id} (${data.executionTime}ms)`);
  }

  handleTaskFailed(data) {
    this.metrics.system.failedTasks++;
    
    const task = this.metrics.tasks.get(data.task.id);
    if (task) {
      task.status = 'failed';
      task.endTime = Date.now();
      task.duration = task.endTime - task.startTime;
      task.error = data.error.message;
    }

    // Mettre √† jour l'agent
    const agent = this.metrics.agents.get(data.agent);
    if (agent) {
      agent.status = 'error';
      agent.tasksFailed++;
      agent.lastActivity = Date.now();
    }

    // Cr√©er une alerte
    this.createAlert('error', `√âchec de t√¢che: ${data.task.id}`, {
      agent: data.agent,
      task: data.task.id,
      error: data.error.message
    });

    this.log(`‚ùå T√¢che √©chou√©e: ${data.task.id} - ${data.error.message}`);
  }

  handleMessageExchanged(data) {
    this.metrics.system.messagesExchanged++;
    this.log(`üì® Message: ${data.from} ‚Üí ${data.to} (${data.message.type})`);
  }

  handleContext7Query(data) {
    if (data.result) {
      this.metrics.performance.context7Hits++;
    } else {
      this.metrics.performance.context7Misses++;
    }
  }

  handleHealthUpdate(data) {
    const agent = this.metrics.agents.get(data.agentId);
    if (agent) {
      agent.health = data.health;
      agent.loadFactor = data.metrics?.loadFactor || 0;
      agent.errorRate = data.metrics?.errorRate || 0;
    }

    // V√©rifier les r√®gles d'alertes
    this.checkAlertRules(data);
  }

  handlePerformanceAlert(data) {
    this.createAlert('warning', data.message, data.details);
  }

  /**
   * üìä MISE √Ä JOUR DES M√âTRIQUES
   */
  updatePerformanceMetrics() {
    // Uptime
    this.metrics.system.uptime = Date.now() - this.metrics.system.startTime;

    // Temps moyen des t√¢ches
    const completedTasks = Array.from(this.metrics.tasks.values())
      .filter(task => task.status === 'completed' && task.duration);
    
    if (completedTasks.length > 0) {
      const totalTime = completedTasks.reduce((sum, task) => sum + task.duration, 0);
      this.metrics.performance.avgTaskTime = Math.round(totalTime / completedTasks.length);
    }

    // Charge syst√®me (bas√©e sur les agents actifs)
    const workingAgents = Array.from(this.metrics.agents.values())
      .filter(agent => agent.status === 'working').length;
    
    this.metrics.performance.systemLoad = 
      this.metrics.system.activeAgents > 0 
        ? Math.round((workingAgents / this.metrics.system.activeAgents) * 100)
        : 0;

    // Utilisation m√©moire (Node.js)
    const memUsage = process.memoryUsage();
    this.metrics.performance.memoryUsage = Math.round(memUsage.heapUsed / 1024 / 1024); // MB
  }

  /**
   * üñ•Ô∏è AFFICHAGE DU DASHBOARD
   */
  updateDisplay() {
    if (!this.isRunning) return;

    console.clear();
    this.displayHeader();
    this.displaySystemMetrics();
    this.displayAgentsStatus();
    this.displayTasksOverview();
    this.displayPerformanceMetrics();
    this.displayAlerts();
    this.displayControls();
  }

  displayHeader() {
    const uptime = this.formatDuration(this.metrics.system.uptime);
    
    console.log(chalk.blue('‚ïê'.repeat(80)));
    console.log(chalk.blue.bold('üìä NUTRICOACH MULTI-AGENTS - MONITORING DASHBOARD'));
    console.log(chalk.blue(`‚è±Ô∏è  Uptime: ${uptime} | üîÑ Refresh: 1s | üìä Agents: ${this.metrics.system.activeAgents}`));
    console.log(chalk.blue('‚ïê'.repeat(80)));
    console.log('');
  }

  displaySystemMetrics() {
    const { system } = this.metrics;
    const successRate = system.totalTasks > 0 
      ? Math.round((system.completedTasks / system.totalTasks) * 100)
      : 0;

    console.log(chalk.cyan('üîß M√âTRIQUES SYST√àME'));
    console.log(chalk.gray('‚îÄ'.repeat(40)));
    
    const metricsDisplay = [
      ['üìã T√¢ches totales', system.totalTasks],
      ['‚úÖ T√¢ches compl√©t√©es', system.completedTasks],
      ['‚ùå T√¢ches √©chou√©es', system.failedTasks],
      ['üìà Taux de succ√®s', `${successRate}%`],
      ['üì® Messages √©chang√©s', system.messagesExchanged],
      ['ü§ñ Agents actifs', system.activeAgents]
    ];

    metricsDisplay.forEach(([label, value]) => {
      const color = this.getMetricColor(label, value);
      console.log(`  ${label}: ${color(value)}`);
    });
    
    console.log('');
  }

  displayAgentsStatus() {
    console.log(chalk.cyan('ü§ñ STATUT DES AGENTS'));
    console.log(chalk.gray('‚îÄ'.repeat(40)));

    if (this.metrics.agents.size === 0) {
      console.log(chalk.gray('  Aucun agent enregistr√©'));
      console.log('');
      return;
    }

    const headers = ['Agent', 'Statut', 'Sant√©', 'T√¢ches', 'Temps moy.', 'Derni√®re activit√©'];
    console.log(chalk.gray(`  ${headers.join(' | ')}`));
    console.log(chalk.gray(`  ${headers.map(h => '‚îÄ'.repeat(h.length)).join('‚îÄ‚îº‚îÄ')}`));

    Array.from(this.metrics.agents.values()).forEach(agent => {
      const status = this.getStatusIcon(agent.status);
      const health = this.getHealthIcon(agent.health);
      const tasks = `${agent.tasksCompleted}/${agent.tasksFailed}`;
      const avgTime = this.formatDuration(agent.avgTaskTime);
      const lastActivity = this.formatRelativeTime(agent.lastActivity);

      console.log(`  ${agent.id.padEnd(8)} | ${status.padEnd(8)} | ${health.padEnd(8)} | ${tasks.padEnd(8)} | ${avgTime.padEnd(10)} | ${lastActivity}`);
    });

    console.log('');
  }

  displayTasksOverview() {
    const runningTasks = Array.from(this.metrics.tasks.values())
      .filter(task => task.status === 'running');

    console.log(chalk.cyan('üìã T√ÇCHES EN COURS'));
    console.log(chalk.gray('‚îÄ'.repeat(40)));

    if (runningTasks.length === 0) {
      console.log(chalk.gray('  Aucune t√¢che en cours'));
    } else {
      runningTasks.slice(0, 5).forEach(task => {
        const duration = this.formatDuration(Date.now() - task.startTime);
        const priority = this.getPriorityIcon(task.priority);
        
        console.log(`  ${priority} ${task.id} (${task.agentId})`);
        console.log(`    ${chalk.gray(task.description)} - ${duration}`);
      });

      if (runningTasks.length > 5) {
        console.log(chalk.gray(`    ... et ${runningTasks.length - 5} autres`));
      }
    }

    console.log('');
  }

  displayPerformanceMetrics() {
    const { performance } = this.metrics;
    
    console.log(chalk.cyan('‚ö° PERFORMANCE'));
    console.log(chalk.gray('‚îÄ'.repeat(40)));

    const performanceDisplay = [
      ['‚è±Ô∏è Temps moyen/t√¢che', this.formatDuration(performance.avgTaskTime)],
      ['üìä Charge syst√®me', `${performance.systemLoad}%`],
      ['üíæ M√©moire utilis√©e', `${performance.memoryUsage} MB`],
      ['üéØ Context7 hits', performance.context7Hits],
      ['‚ùå Context7 misses', performance.context7Misses]
    ];

    performanceDisplay.forEach(([label, value]) => {
      const color = this.getPerformanceColor(label, value);
      console.log(`  ${label}: ${color(value)}`);
    });

    console.log('');
  }

  displayAlerts() {
    const recentAlerts = this.metrics.alerts
      .slice(-5)
      .reverse();

    console.log(chalk.cyan('üö® ALERTES R√âCENTES'));
    console.log(chalk.gray('‚îÄ'.repeat(40)));

    if (recentAlerts.length === 0) {
      console.log(chalk.green('  ‚úÖ Aucune alerte'));
    } else {
      recentAlerts.forEach(alert => {
        const icon = this.getAlertIcon(alert.level);
        const time = this.formatRelativeTime(alert.timestamp);
        
        console.log(`  ${icon} ${alert.message} (${time})`);
        if (alert.details && Object.keys(alert.details).length > 0) {
          console.log(chalk.gray(`    ${JSON.stringify(alert.details)}`));
        }
      });
    }

    console.log('');
  }

  displayControls() {
    console.log(chalk.cyan('üéÆ CONTR√îLES'));
    console.log(chalk.gray('‚îÄ'.repeat(40)));
    console.log('  Ctrl+C : Arr√™ter le monitoring');
    console.log('  Space  : Forcer le rafra√Æchissement');
    console.log('  h      : Afficher l\'aide');
    console.log('');
  }

  /**
   * üö® SYST√àME D'ALERTES
   */
  setupDefaultAlerts() {
    // Alerte de charge syst√®me √©lev√©e
    this.alertRules.set('high-system-load', {
      condition: (metrics) => metrics.performance.systemLoad > 80,
      level: 'warning',
      message: 'Charge syst√®me √©lev√©e',
      cooldown: 60000 // 1 minute
    });

    // Alerte d'agent en erreur prolong√©e
    this.alertRules.set('agent-error-state', {
      condition: (metrics) => {
        return Array.from(metrics.agents.values()).some(agent => 
          agent.status === 'error' && 
          Date.now() - agent.lastActivity > 300000 // 5 minutes
        );
      },
      level: 'error',
      message: 'Agent en erreur prolong√©e',
      cooldown: 300000 // 5 minutes
    });

    // Alerte de taux d'√©chec √©lev√©
    this.alertRules.set('high-failure-rate', {
      condition: (metrics) => {
        const total = metrics.system.totalTasks;
        const failed = metrics.system.failedTasks;
        return total > 10 && (failed / total) > 0.2; // 20% d'√©chec
      },
      level: 'warning',
      message: 'Taux d\'√©chec √©lev√© d√©tect√©',
      cooldown: 180000 // 3 minutes
    });

    // Alerte de m√©moire √©lev√©e
    this.alertRules.set('high-memory-usage', {
      condition: (metrics) => metrics.performance.memoryUsage > 512, // 512 MB
      level: 'warning',
      message: 'Utilisation m√©moire √©lev√©e',
      cooldown: 120000 // 2 minutes
    });
  }

  checkAlertRules(data) {
    this.alertRules.forEach((rule, ruleId) => {
      try {
        if (rule.condition(this.metrics)) {
          // V√©rifier le cooldown
          const lastAlert = this.metrics.alerts
            .reverse()
            .find(alert => alert.ruleId === ruleId);

          if (!lastAlert || Date.now() - lastAlert.timestamp > rule.cooldown) {
            this.createAlert(rule.level, rule.message, { ruleId, trigger: data });
          }
        }
      } catch (error) {
        console.error(`Erreur r√®gle d'alerte ${ruleId}:`, error.message);
      }
    });
  }

  createAlert(level, message, details = {}) {
    const alert = {
      id: `alert-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      level, // info, warning, error, critical
      message,
      details,
      timestamp: Date.now(),
      ruleId: details.ruleId
    };

    this.metrics.alerts.push(alert);

    // Garder seulement les 100 derni√®res alertes
    if (this.metrics.alerts.length > 100) {
      this.metrics.alerts = this.metrics.alerts.slice(-100);
    }

    this.log(`üö® Alerte ${level}: ${message}`);
    this.emit('alert', alert);
  }

  /**
   * üíæ MONITORING SYST√àME
   */
  startSystemMonitoring() {
    setInterval(() => {
      this.updatePerformanceMetrics();
      this.checkAlertRules({});
    }, 5000); // Toutes les 5 secondes
  }

  /**
   * üé® UTILITAIRES D'AFFICHAGE
   */
  getStatusIcon(status) {
    const icons = {
      'idle': chalk.gray('‚ö´ Inactif'),
      'working': chalk.yellow('üü° Actif'),
      'error': chalk.red('üî¥ Erreur'),
      'completed': chalk.green('üü¢ Fini')
    };
    return icons[status] || chalk.gray('‚ùì Inconnu');
  }

  getHealthIcon(health) {
    const icons = {
      'healthy': chalk.green('üíö Sain'),
      'degraded': chalk.yellow('üíõ D√©grad√©'),
      'stressed': chalk.orange('üß° Stress√©'),
      'error': chalk.red('‚ù§Ô∏è Erreur')
    };
    return icons[health] || chalk.gray('üíú Inconnu');
  }

  getPriorityIcon(priority) {
    const icons = {
      'low': chalk.gray('üîπ'),
      'medium': chalk.yellow('üî∏'),
      'high': chalk.orange('üü†'),
      'critical': chalk.red('üî¥')
    };
    return icons[priority] || chalk.gray('‚ö´');
  }

  getAlertIcon(level) {
    const icons = {
      'info': chalk.blue('‚ÑπÔ∏è'),
      'warning': chalk.yellow('‚ö†Ô∏è'),
      'error': chalk.red('‚ùå'),
      'critical': chalk.red('üö®')
    };
    return icons[level] || chalk.gray('üì¢');
  }

  getMetricColor(label, value) {
    if (label.includes('√©chec') && value > 0) return chalk.red;
    if (label.includes('succ√®s') && value >= 95) return chalk.green;
    if (label.includes('succ√®s') && value >= 80) return chalk.yellow;
    if (label.includes('succ√®s') && value < 80) return chalk.red;
    return chalk.white;
  }

  getPerformanceColor(label, value) {
    if (label.includes('Charge') && parseInt(value) > 80) return chalk.red;
    if (label.includes('Charge') && parseInt(value) > 60) return chalk.yellow;
    if (label.includes('M√©moire') && parseInt(value) > 512) return chalk.red;
    if (label.includes('M√©moire') && parseInt(value) > 256) return chalk.yellow;
    return chalk.white;
  }

  /**
   * üîß UTILITAIRES
   */
  formatDuration(ms) {
    if (ms < 1000) return `${ms}ms`;
    if (ms < 60000) return `${Math.round(ms / 1000)}s`;
    if (ms < 3600000) return `${Math.round(ms / 60000)}m`;
    return `${Math.round(ms / 3600000)}h`;
  }

  formatRelativeTime(timestamp) {
    const diff = Date.now() - timestamp;
    if (diff < 60000) return 'maintenant';
    if (diff < 3600000) return `${Math.round(diff / 60000)}m`;
    if (diff < 86400000) return `${Math.round(diff / 3600000)}h`;
    return `${Math.round(diff / 86400000)}j`;
  }

  /**
   * üíæ SAUVEGARDE ET LOGGING
   */
  async saveMetrics() {
    try {
      const metricsSnapshot = {
        timestamp: Date.now(),
        system: this.metrics.system,
        agents: Array.from(this.metrics.agents.values()),
        tasks: Array.from(this.metrics.tasks.values()),
        performance: this.metrics.performance,
        alerts: this.metrics.alerts.slice(-50) // Derni√®res 50 alertes
      };

      const logsDir = path.dirname(this.logFile);
      await fs.mkdir(logsDir, { recursive: true });

      const snapshotFile = path.join(logsDir, `metrics-snapshot-${Date.now()}.json`);
      await fs.writeFile(snapshotFile, JSON.stringify(metricsSnapshot, null, 2));

      this.log(`üíæ M√©triques sauvegard√©es: ${snapshotFile}`);
    } catch (error) {
      console.error('Erreur sauvegarde m√©triques:', error.message);
    }
  }

  async log(message) {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] ${message}\n`;

    try {
      const logsDir = path.dirname(this.logFile);
      await fs.mkdir(logsDir, { recursive: true });
      await fs.appendFile(this.logFile, logEntry);
    } catch (error) {
      // Silently fail to avoid flooding console
    }
  }

  /**
   * üìä API POUR LES M√âTRIQUES
   */
  getMetricsSnapshot() {
    return {
      timestamp: Date.now(),
      system: { ...this.metrics.system },
      agents: Array.from(this.metrics.agents.values()),
      tasks: Array.from(this.metrics.tasks.values()),
      performance: { ...this.metrics.performance },
      alerts: [...this.metrics.alerts]
    };
  }

  getAgentMetrics(agentId) {
    return this.metrics.agents.get(agentId) || null;
  }

  getTaskMetrics(taskId) {
    return this.metrics.tasks.get(taskId) || null;
  }

  getAlerts(level = null, limit = 10) {
    let alerts = [...this.metrics.alerts].reverse();
    
    if (level) {
      alerts = alerts.filter(alert => alert.level === level);
    }

    return alerts.slice(0, limit);
  }
}

export default MonitoringDashboard;