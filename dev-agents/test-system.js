#!/usr/bin/env node

/**
 * üß™ TEST SYST√àME MULTI-AGENTS
 * 
 * Tests d'int√©gration pour valider le bon fonctionnement du syst√®me
 */

import chalk from 'chalk';
import MultiAgentOrchestrator from './orchestrator.js';
import SpecValidator from './lib/spec-validator.js';

class SystemTester {
  constructor() {
    this.tests = [
      { name: 'Validation des sp√©cifications', test: () => this.testSpecValidation() },
      { name: 'Initialisation des agents', test: () => this.testAgentInitialization() },
      { name: 'Communication inter-agents', test: () => this.testInterAgentCommunication() },
      { name: 'Gestion des erreurs', test: () => this.testErrorHandling() },
      { name: 'Orchestration simple', test: () => this.testSimpleOrchestration() }
    ];
    
    this.results = [];
  }

  async runAll() {
    console.log(chalk.blue('üß™ TESTS SYST√àME MULTI-AGENTS'));
    console.log(chalk.blue('‚ïê'.repeat(40)));

    let passed = 0;
    let failed = 0;

    for (const test of this.tests) {
      console.log(chalk.yellow(`\nüîç ${test.name}...`));
      
      try {
        const startTime = Date.now();
        await test.test();
        const duration = Date.now() - startTime;
        
        console.log(chalk.green(`‚úÖ ${test.name} - OK (${duration}ms)`));
        this.results.push({ name: test.name, status: 'PASS', duration });
        passed++;
      } catch (error) {
        console.log(chalk.red(`‚ùå ${test.name} - √âCHEC`));
        console.log(chalk.red(`   Erreur: ${error.message}`));
        this.results.push({ name: test.name, status: 'FAIL', error: error.message });
        failed++;
      }
    }

    this.displaySummary(passed, failed);
    return failed === 0;
  }

  async testSpecValidation() {
    const validator = new SpecValidator();
    
    // Charger le template
    await validator.loadTemplate();
    
    // Test avec une spec valide
    const validSpec = {
      feature: {
        name: 'Test Feature',
        description: 'Feature de test',
        type: 'crud-feature',
        priority: 'medium',
        estimatedTime: '2h'
      },
      agents: {
        'db-agent': {
          required: true,
          tasks: [{
            id: 'test-task',
            type: 'schema',
            description: 'T√¢che de test',
            priority: 'medium',
            estimatedTime: '1h',
            spec: { tableName: 'test_table' }
          }]
        }
      }
    };

    const result = await validator.validateFeature(validSpec, 'test-feature');
    
    if (!result.valid) {
      throw new Error(`Validation √©chou√©: ${result.errors.map(e => e.message).join(', ')}`);
    }

    // Test avec une spec invalide
    const invalidSpec = {
      feature: {
        name: 'Invalid Feature'
        // Champs manquants intentionnellement
      }
    };

    const invalidResult = await validator.validateFeature(invalidSpec, 'invalid-feature');
    
    if (invalidResult.valid) {
      throw new Error('La validation devrait √©chouer pour une spec invalide');
    }

    console.log('  ‚úì Validation des specs valides et invalides');
  }

  async testAgentInitialization() {
    const orchestrator = new MultiAgentOrchestrator();
    
    // V√©rifier que tous les agents sont initialis√©s
    const expectedAgents = ['db-agent', 'ui-agent', 'module-agent', 'qa-agent', 'doc-agent'];
    
    for (const agentId of expectedAgents) {
      if (!orchestrator.agents.has(agentId)) {
        throw new Error(`Agent ${agentId} non initialis√©`);
      }
      
      const agent = orchestrator.agents.get(agentId);
      if (!agent.instance) {
        throw new Error(`Instance de ${agentId} non cr√©√©e`);
      }
    }

    console.log(`  ‚úì ${expectedAgents.length} agents initialis√©s correctement`);
    
    // V√©rifier les capacit√©s des agents
    const dbAgent = orchestrator.agents.get('db-agent');
    if (!dbAgent.capabilities.includes('postgresql')) {
      throw new Error('DB Agent devrait avoir la capacit√© postgresql');
    }

    console.log('  ‚úì Capacit√©s des agents v√©rifi√©es');
  }

  async testInterAgentCommunication() {
    const orchestrator = new MultiAgentOrchestrator();
    
    // Test de routage de message
    let messageReceived = false;
    
    // Mock de la r√©ception de message
    const originalReceiveMessage = orchestrator.agentInstances.get('ui-agent').receiveMessage;
    orchestrator.agentInstances.get('ui-agent').receiveMessage = async (from, message) => {
      messageReceived = true;
      console.log(`  ‚úì Message re√ßu: ${from} ‚Üí ui-agent (${message.type})`);
    };

    // Envoyer un message de test
    await orchestrator.routeMessage({
      from: 'db-agent',
      to: 'ui-agent',
      message: {
        type: 'dependency-ready',
        data: { dependency: 'test-schema' }
      }
    });

    if (!messageReceived) {
      throw new Error('Message non re√ßu par l\'agent destinataire');
    }

    // Restaurer la m√©thode originale
    orchestrator.agentInstances.get('ui-agent').receiveMessage = originalReceiveMessage;
  }

  async testErrorHandling() {
    const orchestrator = new MultiAgentOrchestrator();
    
    // Test de gestion d'erreur avec retry
    const testTask = {
      id: 'error-test-task',
      type: 'test',
      description: 'T√¢che de test d\'erreur',
      priority: 'low',
      estimatedTime: '1m',
      maxRetries: 2
    };

    // Mock d'une t√¢che qui √©choue
    let attemptCount = 0;
    const originalExecuteTask = orchestrator.agentInstances.get('db-agent').executeTask;
    orchestrator.agentInstances.get('db-agent').executeTask = async (task) => {
      attemptCount++;
      if (attemptCount <= 2) {
        throw new Error('Erreur simul√©e');
      }
      return { success: true };
    };

    try {
      await orchestrator.executeTask('db-agent', testTask);
      console.log(`  ‚úì Retry fonctionnel: ${attemptCount} tentatives`);
    } catch (error) {
      // Restaurer la m√©thode originale
      orchestrator.agentInstances.get('db-agent').executeTask = originalExecuteTask;
      throw new Error(`Gestion d'erreur √©chou√©e: ${error.message}`);
    }

    // Restaurer la m√©thode originale
    orchestrator.agentInstances.get('db-agent').executeTask = originalExecuteTask;
  }

  async testSimpleOrchestration() {
    const orchestrator = new MultiAgentOrchestrator();
    
    // Feature de test tr√®s simple
    const testFeature = {
      feature: {
        name: 'Test Simple',
        description: 'Test d\'orchestration basique',
        type: 'crud-feature',
        priority: 'low',
        estimatedTime: '1h'
      },
      agents: {
        'db-agent': {
          required: true,
          tasks: [{
            id: 'test-db-task',
            type: 'schema',
            description: 'T√¢che DB de test',
            priority: 'medium',
            estimatedTime: '30m',
            spec: { tableName: 'test_orchestration' }
          }]
        }
      }
    };

    // Mock des m√©thodes d'ex√©cution pour √©viter les vraies op√©rations
    const originalProcessTask = orchestrator.agentInstances.get('db-agent').processTask;
    orchestrator.agentInstances.get('db-agent').processTask = async (task) => {
      await new Promise(resolve => setTimeout(resolve, 100)); // Simuler du travail
      return {
        success: true,
        files: ['test-schema.sql'],
        documentation: 'Test schema created'
      };
    };

    try {
      // Tester la d√©composition
      const decomposition = await orchestrator.decomposeFeature(testFeature);
      
      if (!decomposition.tasks['db-agent'] || decomposition.tasks['db-agent'].length === 0) {
        throw new Error('D√©composition √©chou√©e - pas de t√¢ches DB');
      }

      console.log('  ‚úì D√©composition de feature');

      // Tester la cr√©ation du plan d'ex√©cution
      const plan = await orchestrator.createExecutionPlan(decomposition);
      
      if (!plan.phases || plan.phases.length === 0) {
        throw new Error('Plan d\'ex√©cution vide');
      }

      console.log(`  ‚úì Plan d'ex√©cution: ${plan.phases.length} phases`);

      // Restaurer la m√©thode originale
      orchestrator.agentInstances.get('db-agent').processTask = originalProcessTask;

    } catch (error) {
      // Restaurer en cas d'erreur
      orchestrator.agentInstances.get('db-agent').processTask = originalProcessTask;
      throw error;
    }
  }

  displaySummary(passed, failed) {
    console.log(chalk.blue('\nüìä R√âSUM√â DES TESTS'));
    console.log(chalk.blue('‚ïê'.repeat(30)));
    
    console.log(`Total: ${passed + failed} tests`);
    console.log(chalk.green(`R√©ussis: ${passed}`));
    console.log(failed > 0 ? chalk.red(`√âchou√©s: ${failed}`) : `√âchou√©s: ${failed}`);
    
    const successRate = Math.round((passed / (passed + failed)) * 100);
    const rateColor = successRate >= 100 ? chalk.green : successRate >= 80 ? chalk.yellow : chalk.red;
    console.log(`Taux de r√©ussite: ${rateColor(successRate + '%')}`);

    if (failed === 0) {
      console.log(chalk.green('\nüéâ Tous les tests sont pass√©s! Le syst√®me est op√©rationnel.'));
    } else {
      console.log(chalk.red('\n‚ö†Ô∏è Certains tests ont √©chou√©. V√©rifiez la configuration.'));
    }

    // D√©tail des r√©sultats
    console.log(chalk.blue('\nüìã D√âTAIL DES R√âSULTATS:'));
    for (const result of this.results) {
      const statusColor = result.status === 'PASS' ? chalk.green : chalk.red;
      const duration = result.duration ? ` (${result.duration}ms)` : '';
      console.log(`  ${statusColor(result.status)} ${result.name}${duration}`);
      
      if (result.error) {
        console.log(chalk.gray(`       ${result.error}`));
      }
    }
  }

  // Test individuel
  async runSingle(testName) {
    const test = this.tests.find(t => t.name.toLowerCase().includes(testName.toLowerCase()));
    
    if (!test) {
      console.log(chalk.red(`‚ùå Test "${testName}" non trouv√©`));
      console.log(chalk.gray('Tests disponibles:'));
      this.tests.forEach(t => console.log(`  - ${t.name}`));
      return false;
    }

    console.log(chalk.blue(`üß™ TEST: ${test.name}`));
    
    try {
      await test.test();
      console.log(chalk.green(`‚úÖ ${test.name} - R√âUSSI`));
      return true;
    } catch (error) {
      console.log(chalk.red(`‚ùå ${test.name} - √âCHOU√â`));
      console.log(chalk.red(`Erreur: ${error.message}`));
      return false;
    }
  }
}

// Usage CLI
if (import.meta.url === `file://${process.argv[1]}`) {
  const tester = new SystemTester();
  
  const testName = process.argv[2];
  
  if (testName) {
    // Test individuel
    tester.runSingle(testName).then(success => {
      process.exit(success ? 0 : 1);
    });
  } else {
    // Tous les tests
    tester.runAll().then(success => {
      process.exit(success ? 0 : 1);
    });
  }
}

export default SystemTester;